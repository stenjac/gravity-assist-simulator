<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gravity Assist Trajectory Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #06060e; color: #ddd;
    font-family: 'IBM Plex Mono', 'SF Mono', monospace;
    height: 100vh; display: flex; flex-direction: column;
    overflow: hidden; user-select: none;
  }
  #controls {
    padding: 6px 14px 8px;
    background: rgba(12,12,22,0.98);
    border-bottom: 1px solid rgba(255,255,255,0.06);
    flex-shrink: 0;
  }
  #title-row {
    display: flex; align-items: center; margin-bottom: 4px;
    flex-wrap: wrap; gap: 8px;
  }
  .logo { color: #ff8844; font-size: 16px; }
  .name { font-size: 11px; font-weight: 700; letter-spacing: 2px; color: #aaa; }
  #status { margin-left: auto; font-size: 10px; letter-spacing: 0.5px; font-weight: 700; }
  #status.reached { color: #00ee77; }
  #status.captured { color: #00ee77; }
  #status.flyby   { color: #ffaa22; }
  #status.missed  { color: #ff6644; }
  #status.escaped { color: #bb88ff; }
  #status.suncrash { color: #ffcc22; }
  #status .detail { color: #666; font-weight: 400; margin-left: 6px; }

  #controls-toggle {
    margin-left: 8px;
    background: none; border: 1px solid rgba(255,255,255,0.08);
    color: #666; font-size: 8px; font-family: inherit;
    padding: 2px 10px; border-radius: 3px; cursor: pointer;
    letter-spacing: 0.5px;
  }
  #controls-toggle:hover { color: #aaa; border-color: rgba(255,255,255,0.15); }
  #controls.collapsed #controls-body { display: none; }
  #controls.collapsed { padding-bottom: 6px; }

  #input-row { display: flex; gap: 10px; margin-bottom: 4px; align-items: end; flex-wrap: wrap; }
  #input-row select {
    background: #111120; border: 1px solid rgba(255,255,255,0.08);
    color: #ddd; padding: 5px 8px; border-radius: 4px;
    font-size: 11px; font-family: inherit; min-width: 150px;
  }
  #launch-btn {
    padding: 6px 22px; white-space: nowrap;
    background: linear-gradient(135deg, #ee5522, #ff8844);
    border: none; border-radius: 4px;
    color: #fff; font-size: 11px; font-weight: 700;
    letter-spacing: 2px; cursor: pointer; font-family: inherit;
  }
  #launch-btn:hover { opacity: 0.9; }
  #launch-btn:disabled { background: rgba(255,136,68,0.12); color: #664422; cursor: not-allowed; }
  #sliders { display: flex; gap: 14px; flex-wrap: wrap; }
  .sg { flex: 1 1 100px; min-width: 80px; }
  .sg label { font-size: 9px; color: #888; letter-spacing: 0.4px; display: block; margin-bottom: 0px; }
  .sg label .v { color: #ccc; font-weight: 600; }
  .sg input[type=range] { width: 100%; cursor: pointer; }

  /* Launch window section */
  #window-section {
    margin-top: 4px; padding-top: 4px;
    border-top: 1px solid rgba(255,255,255,0.04);
  }
  #window-header {
    display: flex; align-items: center; gap: 12px; margin-bottom: 4px; flex-wrap: wrap;
  }
  #window-header .wlabel { font-size: 9px; color: #888; letter-spacing: 0.5px; }
  #window-header .winfo { font-size: 9px; color: #666; }
  #window-header .wideal { color: #00dd66; font-weight: 600; }
  #window-header .wcurrent { color: #ffaa44; font-weight: 600; }
  #launch-date-slider { width: 100%; cursor: pointer; accent-color: #00dd66; }
  #window-strip {
    width: 100%; height: 14px; border-radius: 3px;
    margin-top: 2px; margin-bottom: 2px;
    background: #111; position: relative; overflow: hidden;
  }
  #window-strip canvas { width: 100%; height: 100%; display: block; }
  #window-labels {
    display: flex; justify-content: space-between;
    font-size: 8px; color: #555;
  }

  #tip { margin-top: 6px; font-size: 9px; color: #554433; line-height: 1.5; display: none; }
  #canvas-wrap { flex: 1; position: relative; min-height: 0; }
  #canvas-wrap canvas { width: 100%; height: 100%; display: block; }

  /* Floating flight controls overlay */
  #flight-controls {
    position: absolute; bottom: 10px; right: 10px;
    background: rgba(6,6,14,0.75); backdrop-filter: blur(6px);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 6px; padding: 6px 10px;
    display: flex; flex-direction: column; gap: 2px;
    z-index: 10; min-width: 140px;
  }
  .fc-row { display: flex; flex-direction: column; }
  .fc-row label {
    font-size: 8px; color: #666; letter-spacing: 0.3px;
    display: flex; justify-content: space-between;
  }
  .fc-row label .v { color: #aaa; font-weight: 600; }
  .fc-row input[type=range] { width: 100%; cursor: pointer; margin: 0; height: 14px; }
  .fc-btn {
    background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1);
    color: #aaa; font-size: 9px; font-family: inherit; font-weight: 700;
    padding: 4px 0; border-radius: 4px; cursor: pointer;
    letter-spacing: 1px; width: 100%; text-align: center;
  }
  .fc-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
  .fc-btn.paused { background: rgba(0,238,119,0.12); border-color: rgba(0,238,119,0.25); color: #00ee77; }
  #vel-canvas { cursor: pointer; }
  #boost-slider { accent-color: #ff8844; }
  #angle-slider { accent-color: #5aadff; }
  #zoom-slider  { accent-color: #7ecbc4; }
  #speed-slider { accent-color: #bb88ff; }

  /* Velocity chart */
  #vel-chart-wrap {
    flex-shrink: 0; background: rgba(6,6,14,0.98);
    border-top: 1px solid rgba(255,255,255,0.06);
    display: none; /* hidden until first sim */
  }
  #vel-chart-wrap.visible { display: block; }
  #vel-chart-wrap.collapsed #vel-canvas { display: none; }
  #vel-chart-header {
    display: flex; align-items: center; gap: 10px;
    padding: 4px 16px; cursor: pointer;
  }
  .vcl { font-size: 9px; color: #888; letter-spacing: 0.5px; font-weight: 700; }
  .vci { font-size: 9px; color: #555; flex: 1; }
  #vel-chart-toggle {
    background: none; border: 1px solid rgba(255,255,255,0.08);
    color: #666; font-size: 8px; font-family: inherit;
    padding: 2px 8px; border-radius: 3px; cursor: pointer;
  }
  #vel-chart-toggle:hover { color: #aaa; border-color: rgba(255,255,255,0.15); }
  #vel-canvas { width: 100%; height: 100px; display: block; }

  /* Fuel & Reachability */
  #fuel-section {
    margin-top: 4px; padding-top: 4px;
    border-top: 1px solid rgba(255,255,255,0.04);
  }
  #fuel-header {
    display: flex; align-items: center; gap: 12px; margin-bottom: 4px; flex-wrap: wrap;
  }
  #fuel-header .flabel { font-size: 9px; color: #888; letter-spacing: 0.5px; }
  #fuel-header .fbudget { font-size: 10px; font-weight: 700; }
  #fuel-header .fbudget.ok { color: #00dd66; }
  #fuel-header .fbudget.over { color: #ff5533; }
  #fuel-header .fdetail { font-size: 8px; color: #555; }
  #reachability {
    display: flex; gap: 4px; flex-wrap: wrap; align-items: center;
  }
  .reach-pill {
    font-size: 8px; padding: 2px 6px; border-radius: 3px;
    font-weight: 600; letter-spacing: 0.3px; white-space: nowrap;
  }
  .reach-pill.direct { background: rgba(0,238,119,0.15); color: #00dd66; border: 1px solid rgba(0,238,119,0.2); }
  .reach-pill.assisted { background: rgba(255,170,34,0.12); color: #ffaa22; border: 1px solid rgba(255,170,34,0.15); }
  .reach-pill.unreachable { background: rgba(255,60,40,0.08); color: #664433; border: 1px solid rgba(255,60,40,0.06); }
  .reach-pill .cost { font-weight: 400; opacity: 0.7; }
  #rocket-select {
    background: #111120; border: 1px solid rgba(255,255,255,0.08);
    color: #ddd; padding: 5px 8px; border-radius: 4px;
    font-size: 11px; font-family: inherit;
  }

  /* Maneuver nodes */
  #nodes-section {
    margin-top: 4px; padding-top: 4px;
    border-top: 1px solid rgba(255,255,255,0.04);
  }
  #nodes-header {
    display: flex; align-items: center; gap: 10px; margin-bottom: 4px;
  }
  #nodes-header .nlabel {
    font-size: 9px; color: #888; letter-spacing: 0.5px; font-weight: 700;
  }
  #add-node-btn {
    background: rgba(187,136,255,0.12); border: 1px solid rgba(187,136,255,0.2);
    color: #bb88ff; font-size: 9px; padding: 3px 10px; border-radius: 4px;
    cursor: pointer; font-family: inherit; font-weight: 600;
  }
  #add-node-btn:hover { background: rgba(187,136,255,0.22); }
  #node-total-dv { font-size: 9px; color: #888; }
  #node-list { display: flex; flex-direction: column; gap: 4px; }
  .node-row {
    display: flex; align-items: center; gap: 6px; padding: 4px 8px;
    background: rgba(187,136,255,0.04); border: 1px solid rgba(187,136,255,0.08);
    border-radius: 4px; flex-wrap: wrap;
  }
  .node-row .nid {
    font-size: 9px; font-weight: 700; color: #bb88ff; width: 20px; text-align: center;
  }
  .node-row label { font-size: 8px; color: #666; letter-spacing: 0.3px; }
  .node-row input {
    background: #111120; border: 1px solid rgba(255,255,255,0.08);
    color: #ddd; padding: 3px 5px; border-radius: 3px;
    font-size: 10px; font-family: inherit; width: 60px;
  }
  .node-row input:focus { border-color: rgba(187,136,255,0.3); outline: none; }
  .node-remove {
    background: none; border: none; color: #553333; font-size: 12px;
    cursor: pointer; padding: 2px 4px; line-height: 1;
  }
  .node-remove:hover { color: #ff5533; }
  .node-row .ndv-warn { color: #ff5533; font-size: 8px; font-weight: 600; }
</style>
</head>
<body>

<div id="controls">
  <div id="title-row">
    <span class="logo">‚óà</span>
    <span class="name">GRAVITY ASSIST SIMULATOR</span>
    <span id="status"></span>
    <button id="controls-toggle" title="Toggle controls panel">‚ñ¥ CONTROLS</button>
  </div>
  <div id="controls-body">
  <div id="input-row">
    <div>
      <label style="font-size:9px;color:#888;display:block;margin-bottom:2px">DESTINATION</label>
      <select id="dest-select"></select>
    </div>
    <div>
      <label style="font-size:9px;color:#888;display:block;margin-bottom:2px">ROCKET CLASS</label>
      <select id="rocket-select"></select>
    </div>
    <button id="launch-btn">‚ñ∂ LAUNCH</button>
  </div>
  <div id="sliders">
    <div class="sg">
      <label>BOOST (Œîv): <span class="v" id="boost-val">12%</span></label>
      <input type="range" id="boost-slider" min="1" max="60" step="0.5" value="12">
    </div>
    <div class="sg">
      <label>LAUNCH ANGLE: <span class="v" id="angle-val">0¬∞</span></label>
      <input type="range" id="angle-slider" min="-180" max="180" step="1" value="0">
    </div>
  </div>

  <!-- Launch window section -->
  <div id="window-section">
    <div id="window-header">
      <span class="wlabel">LAUNCH DATE: <span class="v" id="date-val">Day 0</span></span>
      <span class="winfo">Phase angle: <span class="wcurrent" id="phase-current">‚Äî</span></span>
      <span class="winfo">Ideal: <span class="wideal" id="phase-ideal">‚Äî</span></span>
      <span class="winfo" id="transfer-info"></span>
    </div>
    <input type="range" id="launch-date-slider" min="0" max="1200" step="1" value="0">
    <div id="window-strip"><canvas id="strip-canvas"></canvas></div>
    <div id="window-labels">
      <span>Day 0</span>
      <span>Day 300</span>
      <span>Day 600</span>
      <span>Day 900</span>
      <span>Day 1200</span>
    </div>
  </div>

  <!-- Fuel budget & reachability -->
  <div id="fuel-section">
    <div id="fuel-header">
      <span class="flabel">ROCKET: <span class="v" id="rocket-name">‚Äî</span></span>
      <span class="flabel">Œîv BUDGET: <span class="fbudget ok" id="budget-display">‚Äî km/s</span></span>
      <span class="flabel">LAUNCH COST: <span class="v" id="launch-cost-display">‚Äî km/s</span></span>
      <span class="fdetail" id="fuel-equation"></span>
    </div>
    <div style="font-size:8px;color:#555;margin-bottom:4px;letter-spacing:0.3px">REACHABILITY ‚Äî <span style="color:#00dd66">‚ñ†</span> direct <span style="color:#ffaa22">‚ñ†</span> needs assist <span style="color:#443322">‚ñ†</span> out of range</div>
    <div id="reachability"></div>
  </div>

  <!-- Maneuver nodes -->
  <div id="nodes-section">
    <div id="nodes-header">
      <span class="nlabel">MANEUVER NODES</span>
      <button id="add-node-btn">+ ADD BURN</button>
      <span id="node-total-dv"></span>
    </div>
    <div id="node-list"></div>
  </div>
  </div><!-- end controls-body -->

  <div id="tip"></div>
</div>

<div id="vel-chart-wrap">
  <div id="vel-chart-header">
    <span class="vcl">‚ñæ VELOCITY HISTORY</span>
    <span id="vel-chart-info" class="vci"></span>
    <span class="vci" style="color:#444">drag to scrub</span>
    <button id="vel-chart-toggle">‚ñ¥ HIDE</button>
  </div>
  <canvas id="vel-canvas"></canvas>
</div>

<div id="canvas-wrap">
  <canvas id="canvas"></canvas>
  <div id="flight-controls">
    <button id="pause-btn" class="fc-btn" title="Pause / Resume simulation">‚è∏ STOP</button>
    <div class="fc-row">
      <label>ZOOM <span class="v" id="zoom-val">1.0x</span></label>
      <input type="range" id="zoom-slider" min="0.08" max="4" step="0.02" value="1">
    </div>
    <div class="fc-row">
      <label>SPEED <span class="v" id="speed-val">0.1x</span></label>
      <input type="range" id="speed-slider" min="0.0001" max="0.1" step="0.0001" value="0.1">
    </div>
  </div>
</div>

<script>
const AU  = 120;
const PI2 = 2 * Math.PI;
const GM_SUN = PI2 * PI2 * AU * AU * AU;
const EARTH_V = PI2 * AU;
const REAL_EARTH_V_KMS = 29.78;
const BOUNDARY_AU = 80;
const MAX_STEPS = 1500000;
const MAX_DAYS = 1200;

const PLANETS = [
  { name:"Mercury", r:0.387, rad:3,  color:"#c4b8b8", gm:GM_SUN*8e-5,  T:0.241, escVel:4.25  },
  { name:"Venus",   r:0.723, rad:5,  color:"#e8cda0", gm:GM_SUN*3e-4,  T:0.615, escVel:10.36 },
  { name:"Earth",   r:1.0,   rad:5,  color:"#5aadff", gm:GM_SUN*3e-4,  T:1.0,   escVel:11.19 },
  { name:"Mars",    r:1.524, rad:4,  color:"#d4714a", gm:GM_SUN*1.5e-4, T:1.881, escVel:5.03  },
  { name:"Jupiter", r:5.203, rad:11, color:"#d4ad6a", gm:GM_SUN*1.2e-3, T:11.86, escVel:59.5  },
  { name:"Saturn",  r:9.537, rad:9,  color:"#e8d5a3", gm:GM_SUN*4e-4,  T:29.46, escVel:35.5  },
  { name:"Uranus",  r:19.19, rad:7,  color:"#7ecbc4", gm:GM_SUN*8e-5,  T:84.01, escVel:21.3  },
  { name:"Neptune", r:30.07, rad:7,  color:"#5577ee", gm:GM_SUN*8e-5,  T:164.8, escVel:23.5  },
];

function planetPos(p, t) {
  const a = PI2 * t / p.T;
  return { x: p.r * AU * Math.cos(a), y: p.r * AU * Math.sin(a) };
}

// ‚îÄ‚îÄ Œîv costs and rocket classes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Departure Œîv from Earth orbit (km/s above Earth's orbital velocity)
const DV_COSTS = {
  Mercury: { direct: 5.5, assisted: 3.5, assistRoute: "via Venus" },
  Venus:   { direct: 2.5, assisted: 2.5, assistRoute: "direct is optimal" },
  Mars:    { direct: 2.9, assisted: 2.9, assistRoute: "direct is optimal" },
  Jupiter: { direct: 8.8, assisted: 4.0, assistRoute: "via Venus-Earth-Earth" },
  Saturn:  { direct: 10.3, assisted: 4.5, assistRoute: "via Venus-Venus-Earth-Jupiter" },
  Uranus:  { direct: 11.3, assisted: 5.5, assistRoute: "via Jupiter" },
  Neptune: { direct: 11.7, assisted: 6.0, assistRoute: "via Jupiter" },
};

// Rocket classes with Œîv budgets derived from the rocket equation:
// Œîv = ve √ó ln(m0/mf), where ve = Isp √ó 9.81
const ROCKETS = [
  { name: "Scout (Small)", budget: 4.0,  isp: 310, fuelFrac: 0.72,
    desc: "Small launcher, chemical engine. Like Atlas V with a light probe." },
  { name: "Workhorse (Medium)", budget: 7.0, isp: 320, fuelFrac: 0.80,
    desc: "Medium launcher, bipropellant engine. Like Delta IV." },
  { name: "Heavy Lift", budget: 11.0, isp: 450, fuelFrac: 0.82,
    desc: "Heavy launcher, high-efficiency engine. Like SLS or Falcon Heavy + kick stage." },
  { name: "Unlimited (No Limit)", budget: 999, isp: 0, fuelFrac: 0,
    desc: "No fuel constraint. For exploring trajectories freely." },
];

// ‚îÄ‚îÄ Hohmann transfer calculations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function hohmannParams(destPlanet) {
  const r1 = 1.0; // Earth in AU
  const r2 = destPlanet.r;
  const at = (r1 + r2) / 2; // transfer semi-major axis in AU
  const transferPeriod = Math.pow(at, 1.5); // years (Kepler's 3rd)
  const transferTime = transferPeriod / 2; // half orbit

  // How far does destination move during transfer?
  const destAngleMoved = 360 * transferTime / destPlanet.T;

  // Ideal phase angle: destination should be this far ahead of Earth at launch
  // (measured at Sun, from Earth to destination, in direction of orbital motion)
  let idealPhase = 180 - destAngleMoved;
  // Normalize to 0-360
  idealPhase = ((idealPhase % 360) + 360) % 360;

  // Hohmann Œîv as fraction of Earth's orbital speed
  // v_departure = sqrt(GM/r1) * sqrt(2*r2/(r1+r2))
  // Œîv = v_departure - v_earth
  const vRatio = Math.sqrt(2 * r2 / (r1 + r2));
  const boostPct = (vRatio - 1) * 100; // can be negative for inner planets

  return {
    transferTimeDays: transferTime * 365.25,
    idealPhase,
    boostPct: Math.abs(boostPct),
    isInner: r2 < r1,
  };
}

// Phase angle from Earth to destination at time t (measured at Sun, counterclockwise)
function phaseAngle(destPlanet, t) {
  const earth = PLANETS[2];
  const ep = planetPos(earth, t);
  const dp = planetPos(destPlanet, t);
  const eAngle = Math.atan2(ep.y, ep.x);
  const dAngle = Math.atan2(dp.y, dp.x);
  let phase = (dAngle - eAngle) * 180 / Math.PI;
  return ((phase % 360) + 360) % 360;
}

// ‚îÄ‚îÄ Simulation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function simulate(boostPct, angleDeg, destName, launchTimeYears, maneuverNodes) {
  const earth = PLANETS[2];
  const t0 = launchTimeYears;
  const ep = planetPos(earth, t0);
  const aRad = angleDeg * Math.PI / 180;
  const eAng = Math.atan2(ep.y, ep.x);
  const evx = -EARTH_V * Math.sin(eAng);
  const evy =  EARTH_V * Math.cos(eAng);
  const dv = (boostPct / 100) * EARTH_V;

  let x = ep.x, y = ep.y;
  let vx = evx + dv * Math.cos(aRad);
  let vy = evy + dv * Math.sin(aRad);

  const dest = PLANETS.find(p => p.name === destName);
  const dt = 0.00008;
  const trail = [];
  const assists = [];
  const burns = []; // records of executed maneuver burns
  const activeEncounters = {}; // track planets currently in encounter zone
  let time = t0, stopReason = "MAX_TIME";
  let captureInfo = null;

  // Sort nodes by day and convert to simulation units
  const nodes = (maneuverNodes || [])
    .map(n => ({
      timeYears: n.day / 365.25,       // relative to launch
      dvSim: (n.dvKms / REAL_EARTH_V_KMS) * EARTH_V,  // convert km/s to sim units
      angleDeg: n.angleDeg,
      fired: false
    }))
    .sort((a, b) => a.timeYears - b.timeYears);

  for (let i = 0; i < MAX_STEPS; i++) {
    const ds = Math.sqrt(x*x + y*y);
    if (ds < 8) { stopReason = "SUN_CRASH"; break; }
    let ax = -GM_SUN * x / (ds*ds*ds);
    let ay = -GM_SUN * y / (ds*ds*ds);

    // Check for maneuver node burns
    const flightTime = time - t0;
    for (const node of nodes) {
      if (!node.fired && flightTime >= node.timeYears) {
        // Apply the burn ‚Äî angle is relative to current velocity direction
        const curAngle = Math.atan2(vy, vx);
        const burnAngle = curAngle + (node.angleDeg * Math.PI / 180);
        vx += node.dvSim * Math.cos(burnAngle);
        vy += node.dvSim * Math.sin(burnAngle);
        node.fired = true;
        burns.push({
          time: flightTime,
          day: Math.round(flightTime * 365.25),
          x, y,
          dvKms: (node.dvSim / EARTH_V) * REAL_EARTH_V_KMS,
          angleDeg: node.angleDeg,
        });
      }
    }

    for (const p of PLANETS) {
      const pp = planetPos(p, time);
      const dx = pp.x - x, dy = pp.y - y;
      const d = Math.sqrt(dx*dx + dy*dy);
      // Assist detection threshold (how close = "significant encounter")
      const assistThresh = Math.max(p.r * AU * 0.06, 15);
      // Arrival zone for destination must be at LEAST as wide as assist threshold
      const arrivalR = p.name === dest?.name ? Math.max(p.rad * 5, 18, assistThresh) : p.rad * 1.2;
      if (d < arrivalR) {
        if (p.name === dest?.name && (time - t0) > 0.01) {
          stopReason = "ARRIVED";
          // Compute velocity relative to planet
          const pOrbSpeed = PI2 * p.r * AU / p.T;
          const pAngle = Math.atan2(pp.y, pp.x);
          const pvx = -pOrbSpeed * Math.sin(pAngle);
          const pvy =  pOrbSpeed * Math.cos(pAngle);
          const relVx = vx - pvx;
          const relVy = vy - pvy;
          const relSpeed = Math.sqrt(relVx*relVx + relVy*relVy);
          const relSpeedKms = (relSpeed / EARTH_V) * REAL_EARTH_V_KMS;
          const captured = relSpeedKms < p.escVel;
          captureInfo = {
            relVelKms: relSpeedKms,
            escVelKms: p.escVel,
            captured,
          };
        }
        if (p.name === "Earth" && (time - t0) < 0.02) continue;
      }
      if (d > p.rad * 1.2) {
        ax += p.gm * dx / (d*d*d);
        ay += p.gm * dy / (d*d*d);
      }
      // Log gravity assists ‚Äî track entry/exit of encounter zone to measure actual Œîv
      if (p.name !== "Earth" && p.name !== dest?.name && (time - t0) > 0.02) {
        const inZone = d < assistThresh;
        if (inZone && !activeEncounters[p.name]) {
          // Entering encounter zone ‚Äî record pre-encounter speed
          const spdBefore = Math.sqrt(vx*vx + vy*vy);
          activeEncounters[p.name] = {
            spdBefore,
            closestDist: d,
            closestPos: { x: pp.x, y: pp.y },
            entryTime: time - t0,
          };
        } else if (inZone && activeEncounters[p.name]) {
          // Still in zone ‚Äî track closest approach
          const enc = activeEncounters[p.name];
          if (d < enc.closestDist) {
            enc.closestDist = d;
            enc.closestPos = { x: pp.x, y: pp.y };
          }
        } else if (!inZone && activeEncounters[p.name]) {
          // Exiting encounter zone ‚Äî measure post-encounter speed
          const enc = activeEncounters[p.name];
          const spdAfter = Math.sqrt(vx*vx + vy*vy);
          const dvSim = spdAfter - enc.spdBefore; // positive = speed gained
          const dvKms = (dvSim / EARTH_V) * REAL_EARTH_V_KMS;
          // Only log if not a duplicate
          if (!assists.find(a => a.planet === p.name && Math.abs((time - t0) - a.time) < 0.5)) {
            assists.push({
              planet: p.name,
              time: enc.entryTime + (time - t0 - enc.entryTime) / 2, // midpoint
              x: enc.closestPos.x, y: enc.closestPos.y,
              dvKms,
              spdBeforeKms: (enc.spdBefore / EARTH_V) * REAL_EARTH_V_KMS,
              spdAfterKms: (spdAfter / EARTH_V) * REAL_EARTH_V_KMS,
            });
          }
          delete activeEncounters[p.name];
        }
      }
    }
    if (stopReason === "ARRIVED") break;

    vx += ax * dt; vy += ay * dt;
    x  += vx * dt; y  += vy * dt;
    time += dt;

    if (i % 15 === 0) {
      const spd = Math.sqrt(vx*vx + vy*vy);
      trail.push({ x, y, t: time - t0, absT: time, speed: spd });
    }
    if (Math.sqrt(x*x + y*y) > BOUNDARY_AU * AU) { stopReason = "ESCAPED"; break; }
  }
  return { trail, time: time - t0, stopReason, assists, burns, t0, captureInfo };
}

// ‚îÄ‚îÄ DOM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const stripCanvas = document.getElementById("strip-canvas");

// Controls panel collapse/expand
const controlsEl = document.getElementById("controls");
const controlsToggle = document.getElementById("controls-toggle");

function collapseControls() {
  controlsEl.classList.add("collapsed");
  controlsToggle.textContent = "‚ñæ CONTROLS";
  setTimeout(resize, 10); // reclaim canvas space
}
function expandControls() {
  controlsEl.classList.remove("collapsed");
  controlsToggle.textContent = "‚ñ¥ CONTROLS";
  setTimeout(resize, 10);
}
controlsToggle.addEventListener("click", () => {
  if (controlsEl.classList.contains("collapsed")) expandControls();
  else collapseControls();
});

// Velocity chart
const velWrap = document.getElementById("vel-chart-wrap");
const velCanvas = document.getElementById("vel-canvas");
const velCtx = velCanvas.getContext("2d");
const velInfo = document.getElementById("vel-chart-info");
const velToggle = document.getElementById("vel-chart-toggle");

velToggle.addEventListener("click", (e) => {
  e.stopPropagation();
  velWrap.classList.toggle("collapsed");
  const hidden = velWrap.classList.contains("collapsed");
  velToggle.textContent = hidden ? "‚ñæ SHOW" : "‚ñ¥ HIDE";
  if (!hidden) resizeVelChart();
});

function resizeVelChart() {
  const r = velCanvas.getBoundingClientRect();
  velCanvas.width = r.width * devicePixelRatio;
  velCanvas.height = r.height * devicePixelRatio;
  velCtx.scale(devicePixelRatio, devicePixelRatio);
}

// ‚îÄ‚îÄ Pause / Resume ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const pauseBtn = document.getElementById("pause-btn");
let storedBaseFrames = 600;

function pauseSim() {
  if (!running || paused) return;
  paused = true;
  if (animId) { cancelAnimationFrame(animId); animId = null; }
  pauseBtn.textContent = "‚ñ∂ RESUME";
  pauseBtn.classList.add("paused");
  launchBtn.disabled = false;
  launchBtn.textContent = "‚ñ∂ LAUNCH";
}

function resumeSim() {
  if (!running || !paused) return;
  paused = false;
  pauseBtn.textContent = "‚è∏ STOP";
  pauseBtn.classList.remove("paused");
  launchBtn.disabled = true;
  launchBtn.textContent = "‚ü≥ RUNNING...";

  let lastTime = performance.now();
  function tick(now) {
    if (paused) return;
    const animSpeed = +speedSlider.value;
    const elapsed = (now - lastTime) / 1000;
    lastTime = now;
    const increment = (animSpeed * elapsed * 60) / storedBaseFrames;
    progress = Math.min(progress + increment, 1);
    draw(progress);
    if (progress < 1) {
      animId = requestAnimationFrame(tick);
    } else {
      running = false; paused = false;
      launchBtn.disabled = false;
      launchBtn.textContent = "‚ñ∂ LAUNCH";
      pauseBtn.textContent = "‚è∏ STOP";
      pauseBtn.classList.remove("paused");
      showStatus();
    }
  }
  animId = requestAnimationFrame(tick);
}

pauseBtn.addEventListener("click", () => {
  if (!running) return;
  if (paused) resumeSim(); else pauseSim();
});

// ‚îÄ‚îÄ Velocity chart scrubber (click & drag to seek) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function velChartSeek(e) {
  if (!result || result.trail.length < 2) return;
  const rect = velCanvas.getBoundingClientRect();
  const ml = 52, mr = 14;
  const cw = rect.width - ml - mr;
  const x = e.clientX - rect.left - ml;
  const frac = Math.max(0, Math.min(1, x / cw));
  progress = frac;
  // Pause if still running
  if (running && !paused) pauseSim();
  draw(progress);
  if (progress >= 1) showStatus();
}

let velDragging = false;
velCanvas.addEventListener("mousedown", (e) => {
  velDragging = true;
  velChartSeek(e);
});
window.addEventListener("mousemove", (e) => {
  if (velDragging) velChartSeek(e);
});
window.addEventListener("mouseup", () => { velDragging = false; });

// Touch support for scrubber
velCanvas.addEventListener("touchstart", (e) => {
  velDragging = true;
  velChartSeek(e.touches[0]);
  e.preventDefault();
}, { passive: false });
window.addEventListener("touchmove", (e) => {
  if (velDragging) velChartSeek(e.touches[0]);
});
window.addEventListener("touchend", () => { velDragging = false; });
const stripCtx = stripCanvas.getContext("2d");
const destSel = document.getElementById("dest-select");
const launchBtn = document.getElementById("launch-btn");
const statusEl = document.getElementById("status");
const tipEl = document.getElementById("tip");
const boostSlider = document.getElementById("boost-slider");
const angleSlider = document.getElementById("angle-slider");
const zoomSlider  = document.getElementById("zoom-slider");
const speedSlider = document.getElementById("speed-slider");
const dateSlider  = document.getElementById("launch-date-slider");
const boostVal = document.getElementById("boost-val");
const angleVal = document.getElementById("angle-val");
const zoomVal  = document.getElementById("zoom-val");
const speedVal = document.getElementById("speed-val");
const dateVal  = document.getElementById("date-val");
const phaseCurrent = document.getElementById("phase-current");
const phaseIdeal   = document.getElementById("phase-ideal");
const transferInfo = document.getElementById("transfer-info");
const rocketSel = document.getElementById("rocket-select");
const budgetDisplay = document.getElementById("budget-display");
const launchCostDisplay = document.getElementById("launch-cost-display");
const rocketNameDisplay = document.getElementById("rocket-name");
const fuelEquation = document.getElementById("fuel-equation");
const reachabilityEl = document.getElementById("reachability");

PLANETS.filter(p => p.name !== "Earth").forEach(p => {
  const opt = document.createElement("option");
  opt.value = p.name; opt.textContent = `${p.name} (${p.r} AU)`;
  destSel.appendChild(opt);
});

ROCKETS.forEach((r, i) => {
  const opt = document.createElement("option");
  opt.value = i;
  opt.textContent = r.budget < 100 ? `${r.name} ‚Äî ${r.budget} km/s` : `${r.name}`;
  rocketSel.appendChild(opt);
});

function getCurrentRocket() { return ROCKETS[+rocketSel.value]; }
function getBoostKms() { return (+boostSlider.value / 100) * REAL_EARTH_V_KMS; }

function updateBoostDisplay() {
  const pct = +boostSlider.value;
  const kms = getBoostKms();
  const rocket = getCurrentRocket();
  const maxKms = rocket.budget < 100 ? rocket.budget : 60 * REAL_EARTH_V_KMS / 100;
  const atMax = rocket.budget < 100 && Math.abs(kms - rocket.budget) < 0.2;
  const pctOfBudget = rocket.budget < 100 ? (kms / rocket.budget * 100).toFixed(0) : null;

  let label = `${pct.toFixed(1)}% (${kms.toFixed(1)} km/s)`;
  if (atMax) label += " ‚Üê MAX";
  boostVal.textContent = label;
  boostVal.style.color = atMax ? "#ff8844" : "#ccc";

  launchCostDisplay.textContent = pctOfBudget
    ? `${kms.toFixed(1)} km/s (${pctOfBudget}% of budget)`
    : `${kms.toFixed(1)} km/s`;
  launchCostDisplay.style.color = atMax ? "#ff8844" : "#ccc";
}

function updateRocketInfo() {
  const rocket = getCurrentRocket();
  rocketNameDisplay.textContent = rocket.name;

  // Constrain boost slider to rocket's Œîv budget
  const maxPct = rocket.budget < 100
    ? (rocket.budget / REAL_EARTH_V_KMS * 100).toFixed(1)
    : 60;
  boostSlider.max = maxPct;

  // Clamp current value if it exceeds new max
  if (+boostSlider.value > +maxPct) {
    boostSlider.value = maxPct;
  }

  // Set a smart default: use Hohmann ideal for current destination, clamped to budget
  const dest = PLANETS.find(p => p.name === destSel.value);
  if (dest) {
    const h = hohmannParams(dest);
    const idealPct = Math.min(h.boostPct, +maxPct);
    boostSlider.value = Math.max(1, idealPct).toFixed(1);
  }

  if (rocket.budget < 100) {
    budgetDisplay.textContent = rocket.budget.toFixed(1) + " km/s";
    budgetDisplay.className = "fbudget ok";
    fuelEquation.textContent = rocket.isp > 0
      ? `Isp=${rocket.isp}s ¬∑ ${(rocket.fuelFrac*100).toFixed(0)}% fuel ¬∑ Œîv = ${rocket.budget} km/s`
      : "";
  } else {
    budgetDisplay.textContent = "‚àû";
    budgetDisplay.className = "fbudget ok";
    fuelEquation.textContent = "";
  }
  updateBoostDisplay();
  updateReachability();
}

function updateReachability() {
  const rocket = getCurrentRocket();
  const budget = rocket.budget;
  reachabilityEl.innerHTML = "";

  for (const pName of Object.keys(DV_COSTS)) {
    const costs = DV_COSTS[pName];
    const pill = document.createElement("span");
    pill.className = "reach-pill";

    if (budget >= costs.direct) {
      pill.classList.add("direct");
      pill.innerHTML = `${pName} <span class="cost">${costs.direct}</span>`;
      pill.title = `Direct: ${costs.direct} km/s ‚Äî within budget`;
    } else if (budget >= costs.assisted) {
      pill.classList.add("assisted");
      pill.innerHTML = `${pName} <span class="cost">${costs.assisted}‚òÖ</span>`;
      pill.title = `Direct: ${costs.direct} km/s (over budget!) ¬∑ With assist ${costs.assistRoute}: ${costs.assisted} km/s ‚úì`;
    } else {
      pill.classList.add("unreachable");
      pill.innerHTML = `${pName} <span class="cost">${costs.direct}</span>`;
      pill.title = `Direct: ${costs.direct} km/s ¬∑ Assisted: ${costs.assisted} km/s ‚Äî both over budget`;
    }
    reachabilityEl.appendChild(pill);
  }
}

rocketSel.onchange = updateRocketInfo;

// ‚îÄ‚îÄ Maneuver Nodes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const maneuverNodes = [];
const nodeListEl = document.getElementById("node-list");
const nodeTotalDvEl = document.getElementById("node-total-dv");
const addNodeBtn = document.getElementById("add-node-btn");

function addNode(day, dvKms, angleDeg) {
  maneuverNodes.push({ day: day || 200, dvKms: dvKms || 1.0, angleDeg: angleDeg || 0 });
  renderNodes();
}

function removeNode(idx) {
  maneuverNodes.splice(idx, 1);
  renderNodes();
}

function renderNodes() {
  nodeListEl.innerHTML = "";
  const rocket = getCurrentRocket();
  const launchDv = getBoostKms();
  let totalNodeDv = 0;

  maneuverNodes.forEach((node, idx) => {
    totalNodeDv += node.dvKms;
    const row = document.createElement("div");
    row.className = "node-row";

    const cumDv = launchDv + maneuverNodes.slice(0, idx + 1).reduce((s, n) => s + n.dvKms, 0);
    const overBudget = rocket.budget < 100 && cumDv > rocket.budget;

    row.innerHTML = `
      <span class="nid">‚óÜ${idx + 1}</span>
      <label>DAY</label><input type="number" class="n-day" value="${node.day}" min="1" max="50000" step="1">
      <label>Œîv (km/s)</label><input type="number" class="n-dv" value="${node.dvKms}" min="0.1" max="20" step="0.1">
      <label>ANGLE</label><input type="number" class="n-angle" value="${node.angleDeg}" min="-180" max="180" step="1">
      ${overBudget ? '<span class="ndv-warn">OVER BUDGET</span>' : ''}
      <button class="node-remove" title="Remove this burn">‚úï</button>
    `;

    // Wire up inputs
    row.querySelector(".n-day").addEventListener("input", (e) => {
      node.day = Math.max(1, +e.target.value || 1);
      updateNodeTotals();
    });
    row.querySelector(".n-dv").addEventListener("input", (e) => {
      node.dvKms = Math.max(0.1, +e.target.value || 0.1);
      updateNodeTotals();
    });
    row.querySelector(".n-angle").addEventListener("input", (e) => {
      node.angleDeg = +e.target.value || 0;
    });
    row.querySelector(".node-remove").addEventListener("click", () => removeNode(idx));

    nodeListEl.appendChild(row);
  });

  updateNodeTotals();
}

function updateNodeTotals() {
  const rocket = getCurrentRocket();
  const launchDv = getBoostKms();
  const nodeDv = maneuverNodes.reduce((s, n) => s + n.dvKms, 0);
  const totalDv = launchDv + nodeDv;
  const hasBudget = rocket.budget < 100;

  if (maneuverNodes.length === 0) {
    nodeTotalDvEl.textContent = "";
    return;
  }

  const overBudget = hasBudget && totalDv > rocket.budget;
  const remaining = hasBudget ? Math.max(rocket.budget - totalDv, 0) : Infinity;

  let txt = `Launch: ${launchDv.toFixed(1)} + Burns: ${nodeDv.toFixed(1)} = ${totalDv.toFixed(1)} km/s total`;
  if (hasBudget) {
    txt += overBudget
      ? ` ¬∑ OVER BUDGET by ${(totalDv - rocket.budget).toFixed(1)} km/s`
      : ` ¬∑ ${remaining.toFixed(1)} km/s remaining`;
  }
  nodeTotalDvEl.textContent = txt;
  nodeTotalDvEl.style.color = overBudget ? "#ff5533" : "#888";

  // Re-render to update over-budget warnings per row
  // (avoid infinite loop ‚Äî only re-render if needed)
}

function getTotalDv() {
  return getBoostKms() + maneuverNodes.reduce((s, n) => s + n.dvKms, 0);
}

addNodeBtn.addEventListener("click", () => {
  // Smart default: suggest a day based on current destination's transfer time
  const dest = PLANETS.find(p => p.name === destSel.value);
  let defaultDay = 200;
  if (dest) {
    const h = hohmannParams(dest);
    defaultDay = Math.round(h.transferTimeDays * 0.4); // ~40% of transfer time
  }
  addNode(defaultDay, 1.0, 0);
});

boostSlider.oninput = () => { updateBoostDisplay(); updateNodeTotals(); };
angleSlider.oninput = () => { angleVal.textContent = angleSlider.value + "¬∞"; };
zoomSlider.oninput  = () => { zoomVal.textContent = (+zoomSlider.value).toFixed(1) + "x"; draw(progress); };
speedSlider.oninput = () => {
  const v = +speedSlider.value;
  speedVal.textContent = v < 0.01 ? v.toFixed(3) + "x" : v < 0.1 ? v.toFixed(2) + "x" : v.toFixed(1) + "x";
};

function updateDateDisplay() {
  const day = +dateSlider.value;
  dateVal.textContent = "Day " + day;
  const dest = PLANETS.find(p => p.name === destSel.value);
  if (dest) {
    const t = day / 365.25;
    const pa = phaseAngle(dest, t);
    phaseCurrent.textContent = pa.toFixed(1) + "¬∞";
  }
  draw(progress);
}

dateSlider.oninput = updateDateDisplay;

function updateWindowInfo() {
  const dest = PLANETS.find(p => p.name === destSel.value);
  if (!dest) return;
  const h = hohmannParams(dest);
  phaseIdeal.textContent = h.idealPhase.toFixed(1) + "¬∞";
  transferInfo.innerHTML = `Transfer: ~${Math.round(h.transferTimeDays)} days ¬∑ Ideal boost: ~${h.boostPct.toFixed(0)}%${h.isInner ? " (retrograde)" : ""}`;

  // Auto-set zoom
  let z = dest.r <= 1.6 ? 2.8 : dest.r <= 6 ? 0.75 : dest.r <= 20 ? 0.32 : 0.18;
  zoomSlider.value = z;
  zoomVal.textContent = z.toFixed(1) + "x";

  drawWindowStrip(dest);
  updateDateDisplay();
}

destSel.onchange = () => { updateWindowInfo(); updateRocketInfo(); };

// ‚îÄ‚îÄ Window quality strip ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawWindowStrip(dest) {
  const rect = stripCanvas.parentElement.getBoundingClientRect();
  stripCanvas.width = rect.width;
  stripCanvas.height = rect.height;
  const W = stripCanvas.width, H = stripCanvas.height;
  const h = hohmannParams(dest);

  for (let px = 0; px < W; px++) {
    const day = (px / W) * MAX_DAYS;
    const t = day / 365.25;
    const pa = phaseAngle(dest, t);

    // How close is this to ideal? (circular distance)
    let diff = Math.abs(pa - h.idealPhase);
    if (diff > 180) diff = 360 - diff;

    // Window quality: 0 = perfect, 180 = worst
    const quality = 1 - (diff / 180);
    const isGood = diff < 20;
    const isOk = diff < 45;

    let r, g, b;
    if (isGood) {
      // Bright green
      const f = 1 - diff / 20;
      r = 0; g = Math.round(150 + 105 * f); b = Math.round(60 * f);
    } else if (isOk) {
      // Yellow-ish
      const f = 1 - (diff - 20) / 25;
      r = Math.round(120 * f); g = Math.round(100 * f); b = 0;
    } else {
      // Dark
      r = Math.round(30 * quality); g = Math.round(20 * quality); b = Math.round(15 * quality);
    }

    stripCtx.fillStyle = `rgb(${r},${g},${b})`;
    stripCtx.fillRect(px, 0, 1, H);
  }

  // Draw "WINDOW" labels on bright spots
  stripCtx.font = "bold 7px 'IBM Plex Mono', monospace";
  stripCtx.textAlign = "center";
  stripCtx.fillStyle = "rgba(255,255,255,0.7)";

  // Find window centers (local minima of diff)
  let prevDiff = 999, windowCenters = [];
  for (let day = 0; day < MAX_DAYS; day += 1) {
    const t = day / 365.25;
    const pa = phaseAngle(dest, t);
    let diff = Math.abs(pa - h.idealPhase);
    if (diff > 180) diff = 360 - diff;
    if (diff < 15 && diff < prevDiff) {
      // We're approaching a minimum
    } else if (prevDiff < 15 && diff >= prevDiff && windowCenters.length === 0 || 
               (windowCenters.length > 0 && day - windowCenters[windowCenters.length-1] > 60)) {
      if (prevDiff < 15) windowCenters.push(day - 1);
    }
    prevDiff = diff;
  }
  
  for (const center of windowCenters) {
    const px = (center / MAX_DAYS) * W;
    stripCtx.fillText("‚ñº WINDOW", px, 10);
  }
}

// ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let result = null, animId = null, progress = 0, running = false, paused = false;

function resize() {
  const wrap = canvas.parentElement;
  canvas.width = wrap.clientWidth;
  canvas.height = wrap.clientHeight;
  if (velWrap.classList.contains("visible")) resizeVelChart();
  draw(progress);
  // Also resize strip
  const dest = PLANETS.find(p => p.name === destSel.value);
  if (dest) drawWindowStrip(dest);
}
window.addEventListener("resize", resize);

const stars = [];
for (let i = 0; i < 250; i++)
  stars.push({ x: Math.random(), y: Math.random(), b: 0.06 + Math.random() * 0.35 });

// ‚îÄ‚îÄ Main draw ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function draw(prog) {
  const W = canvas.width, H = canvas.height;
  const cx = W / 2, cy = H / 2;
  const z = +zoomSlider.value;
  const destName = destSel.value;
  const dest = PLANETS.find(p => p.name === destName);
  const launchDay = +dateSlider.value;
  const launchTimeYears = launchDay / 365.25;

  ctx.fillStyle = "#06060e";
  ctx.fillRect(0, 0, W, H);

  for (const s of stars) {
    ctx.fillStyle = `rgba(255,255,255,${s.b})`;
    ctx.fillRect(s.x * W, s.y * H, 1, 1);
  }

  // Sun
  const sunR = 20 * Math.max(z, 0.3);
  const sGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, sunR);
  sGrad.addColorStop(0, "#ffee66"); sGrad.addColorStop(0.25, "#ffbb22");
  sGrad.addColorStop(0.6, "rgba(255,140,0,0.08)"); sGrad.addColorStop(1, "transparent");
  ctx.fillStyle = sGrad;
  ctx.beginPath(); ctx.arc(cx, cy, sunR, 0, PI2); ctx.fill();
  ctx.fillStyle = "#ffee88";
  ctx.beginPath(); ctx.arc(cx, cy, Math.max(3, 4 * z), 0, PI2); ctx.fill();

  // Determine current time: if sim running, use trail time; else use launch date slider
  const trail = result ? result.trail : [];
  const visCount = Math.floor(prog * trail.length);
  const curPoint = visCount > 0 ? trail[visCount - 1] : null;
  const displayTime = curPoint ? curPoint.absT : launchTimeYears;

  // Planets
  for (const p of PLANETS) {
    const orbitR = p.r * AU * z;
    if (orbitR > 4 && orbitR < Math.max(W, H) * 0.8) {
      ctx.strokeStyle = "rgba(255,255,255,0.04)";
      ctx.lineWidth = 1; ctx.setLineDash([2, 5]);
      ctx.beginPath(); ctx.arc(cx, cy, orbitR, 0, PI2); ctx.stroke();
      ctx.setLineDash([]);
    }
    const pos = planetPos(p, displayTime);
    const px = cx + pos.x * z, py = cy + pos.y * z;
    const pr = Math.max(p.rad * z, 2);

    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(px, py, pr, 0, PI2); ctx.fill();

    if (p.name === "Saturn" && pr > 3) {
      ctx.strokeStyle = "rgba(232,213,163,0.35)";
      ctx.lineWidth = Math.max(1, 1.5 * z);
      ctx.beginPath(); ctx.ellipse(px, py, pr * 2.2, pr * 0.5, 0.4, 0, PI2); ctx.stroke();
    }
    if (pr > 2) {
      ctx.fillStyle = "rgba(255,255,255,0.45)";
      ctx.font = `${Math.max(8, Math.min(11, 10 * z))}px 'IBM Plex Mono', monospace`;
      ctx.textAlign = "center";
      ctx.fillText(p.name, px, py - pr - 4);
    }
  }

  // ‚îÄ‚îÄ Phase angle visualization (before launch / no sim running) ‚îÄ‚îÄ
  if (dest && !curPoint) {
    const earth = PLANETS[2];
    const ep = planetPos(earth, displayTime);
    const dp = planetPos(dest, displayTime);
    const epx = cx + ep.x * z, epy = cy + ep.y * z;
    const dpx = cx + dp.x * z, dpy = cy + dp.y * z;

    // Lines from Sun to Earth and Sun to destination
    ctx.strokeStyle = "rgba(90,170,255,0.25)";
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(epx, epy); ctx.stroke();

    ctx.strokeStyle = "rgba(0,255,120,0.25)";
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(dpx, dpy); ctx.stroke();
    ctx.setLineDash([]);

    // Phase angle arc
    const eAngle = Math.atan2(ep.y, ep.x);
    const dAngle = Math.atan2(dp.y, dp.x);
    const arcR = 35 * Math.max(z, 0.4);
    
    const pa = phaseAngle(dest, displayTime);
    const h = hohmannParams(dest);
    let diff = Math.abs(pa - h.idealPhase);
    if (diff > 180) diff = 360 - diff;
    const isGood = diff < 20;

    ctx.strokeStyle = isGood ? "rgba(0,255,120,0.6)" : "rgba(255,170,70,0.4)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, arcR, eAngle, dAngle, false);
    ctx.stroke();

    // Phase angle text at midpoint of arc
    const midAngle = (eAngle + dAngle) / 2;
    const textR = arcR + 14;
    const tx = cx + textR * Math.cos(midAngle);
    const ty = cy + textR * Math.sin(midAngle);
    ctx.fillStyle = isGood ? "rgba(0,255,120,0.85)" : "rgba(255,170,70,0.7)";
    ctx.font = "bold 10px 'IBM Plex Mono', monospace";
    ctx.textAlign = "center";
    ctx.fillText(pa.toFixed(0) + "¬∞", tx, ty);

    if (isGood) {
      ctx.fillStyle = "rgba(0,255,120,0.6)";
      ctx.font = "bold 8px 'IBM Plex Mono', monospace";
      ctx.fillText("‚úì GOOD WINDOW", tx, ty + 12);
    }
  }

  // Destination highlight
  if (dest) {
    const dp = planetPos(dest, displayTime);
    const dpx = cx + dp.x * z, dpy = cy + dp.y * z;
    const destR = Math.max(dest.rad * z, 3);
    const pulse = 0.4 + 0.3 * Math.sin(Date.now() / 200);

    ctx.strokeStyle = `rgba(0,255,120,${pulse * 0.6})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(dpx, dpy, destR + 16 + 3 * Math.sin(Date.now() / 300), 0, PI2); ctx.stroke();

    ctx.strokeStyle = `rgba(0,255,120,${pulse})`;
    ctx.lineWidth = 1.5; ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.arc(dpx, dpy, destR + 9, 0, PI2); ctx.stroke();
    ctx.setLineDash([]);

    const ch = destR + 22;
    ctx.strokeStyle = `rgba(0,255,120,${pulse * 0.4})`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(dpx - ch, dpy); ctx.lineTo(dpx - destR - 18, dpy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(dpx + destR + 18, dpy); ctx.lineTo(dpx + ch, dpy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(dpx, dpy - ch); ctx.lineTo(dpx, dpy - destR - 18); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(dpx, dpy + destR + 18); ctx.lineTo(dpx, dpy + ch); ctx.stroke();

    ctx.fillStyle = `rgba(0,255,120,0.85)`;
    ctx.font = "bold 9px 'IBM Plex Mono', monospace";
    ctx.textAlign = "center";
    ctx.fillText("‚ñº TARGET: " + dest.name.toUpperCase(), dpx, dpy - destR - 24);
  }

  // Trajectory trail
  if (trail.length > 1 && visCount > 1) {
    ctx.lineWidth = 2;
    for (let i = 1; i < visCount; i++) {
      const f = i / visCount;
      const r = 60 + 200 * f | 0;
      const g = 220 * (1 - f * 0.6) | 0;
      const b = 255 * (1 - f) | 0;
      ctx.strokeStyle = `rgba(${r},${g},${b},${0.25 + f * 0.65})`;
      ctx.beginPath();
      ctx.moveTo(cx + trail[i-1].x * z, cy + trail[i-1].y * z);
      ctx.lineTo(cx + trail[i].x * z, cy + trail[i].y * z);
      ctx.stroke();
    }

    // Rocket
    const h = trail[visCount - 1];
    const hx = cx + h.x * z, hy = cy + h.y * z;

    const g1 = ctx.createRadialGradient(hx, hy, 0, hx, hy, 22);
    g1.addColorStop(0, "rgba(255,120,60,0.3)");
    g1.addColorStop(0.5, "rgba(255,80,30,0.08)");
    g1.addColorStop(1, "transparent");
    ctx.fillStyle = g1;
    ctx.beginPath(); ctx.arc(hx, hy, 22, 0, PI2); ctx.fill();

    const g2 = ctx.createRadialGradient(hx, hy, 0, hx, hy, 10);
    g2.addColorStop(0, "#ffffff"); g2.addColorStop(0.3, "#ffaa55");
    g2.addColorStop(0.7, "rgba(255,100,40,0.3)"); g2.addColorStop(1, "transparent");
    ctx.fillStyle = g2;
    ctx.beginPath(); ctx.arc(hx, hy, 10, 0, PI2); ctx.fill();

    ctx.fillStyle = "#fff";
    ctx.beginPath(); ctx.arc(hx, hy, 3, 0, PI2); ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.ellipse(hx, hy, 14, 14, Date.now() / 400, 0, PI2); ctx.stroke();

    ctx.fillStyle = "rgba(255,200,150,0.9)";
    ctx.font = "bold 9px 'IBM Plex Mono', monospace";
    ctx.textAlign = "center";
    ctx.fillText("üöÄ ROCKET", hx, hy - 20);
  }

  // Gravity assist markers
  if (result && result.assists) {
    for (const a of result.assists) {
      if (a.time > (curPoint ? curPoint.t : 0)) continue;
      const ax2 = cx + a.x * z, ay2 = cy + a.y * z;
      const ag = ctx.createRadialGradient(ax2, ay2, 0, ax2, ay2, 18);
      ag.addColorStop(0, "rgba(255,220,40,0.2)"); ag.addColorStop(1, "transparent");
      ctx.fillStyle = ag;
      ctx.beginPath(); ctx.arc(ax2, ay2, 18, 0, PI2); ctx.fill();
      ctx.strokeStyle = "rgba(255,220,40,0.5)"; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(ax2, ay2, 12, 0, PI2); ctx.stroke();
      ctx.fillStyle = "rgba(255,220,40,0.8)";
      ctx.font = "bold 8px monospace"; ctx.textAlign = "center";
      ctx.fillText("‚ö° " + a.planet, ax2, ay2 - 22);
      const dvSign = a.dvKms >= 0 ? "+" : "";
      ctx.font = "7px monospace";
      ctx.fillStyle = a.dvKms >= 0 ? "rgba(0,238,119,0.8)" : "rgba(255,100,50,0.8)";
      ctx.fillText(dvSign + a.dvKms.toFixed(1) + " km/s", ax2, ay2 - 13);
    }
  }

  // Maneuver burn markers
  if (result && result.burns) {
    for (let bi = 0; bi < result.burns.length; bi++) {
      const b = result.burns[bi];
      if (b.time > (curPoint ? curPoint.t : 0)) continue;
      const bx = cx + b.x * z, by = cy + b.y * z;
      // Purple diamond
      const dSize = 7;
      ctx.fillStyle = "rgba(187,136,255,0.25)";
      ctx.beginPath();
      ctx.moveTo(bx, by - dSize - 6);
      ctx.lineTo(bx + dSize + 6, by);
      ctx.lineTo(bx, by + dSize + 6);
      ctx.lineTo(bx - dSize - 6, by);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = "rgba(187,136,255,0.6)"; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(bx, by - dSize);
      ctx.lineTo(bx + dSize, by);
      ctx.lineTo(bx, by + dSize);
      ctx.lineTo(bx - dSize, by);
      ctx.closePath(); ctx.stroke();
      ctx.fillStyle = "rgba(187,136,255,0.9)";
      ctx.font = "bold 8px monospace"; ctx.textAlign = "center";
      ctx.fillText(`‚óÜ BURN ${bi + 1}`, bx, by - dSize - 8);
      ctx.fillStyle = "rgba(187,136,255,0.65)";
      ctx.font = "7px monospace";
      ctx.fillText(`${b.dvKms.toFixed(1)} km/s ¬∑ Day ${b.day}`, bx, by + dSize + 12);
    }
  }

  // HUD
  if (curPoint && result) {
    const speedKms = (curPoint.speed / EARTH_V) * REAL_EARTH_V_KMS;
    const daysFlight = (curPoint.t * 365.25).toFixed(0);

    let distAU = "‚Äî";
    if (dest) {
      const dp = planetPos(dest, curPoint.absT);
      const dx = curPoint.x - dp.x, dy = curPoint.y - dp.y;
      distAU = (Math.sqrt(dx*dx + dy*dy) / AU).toFixed(2);
    }

    const rocket = getCurrentRocket();
    const launchDv = getBoostKms();
    const hasBudget = rocket.budget < 100;
    const hudH = hasBudget ? 96 : 72;

    const hudX = 14, hudY = 12;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    roundRect(ctx, hudX, hudY, 195, hudH, 6); ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.08)"; ctx.lineWidth = 1;
    roundRect(ctx, hudX, hudY, 195, hudH, 6); ctx.stroke();

    ctx.textAlign = "left";
    ctx.font = "bold 9px 'IBM Plex Mono', monospace";
    ctx.fillStyle = "#ff8844";
    ctx.fillText("SPEED", hudX + 10, hudY + 18);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 14px 'IBM Plex Mono', monospace";
    ctx.fillText(speedKms.toFixed(1) + " km/s", hudX + 10, hudY + 35);

    ctx.font = "9px 'IBM Plex Mono', monospace";
    ctx.fillStyle = "#888";
    ctx.fillText("DAY " + daysFlight, hudX + 120, hudY + 18);

    ctx.fillStyle = "#00dd66";
    ctx.font = "bold 9px 'IBM Plex Mono', monospace";
    ctx.fillText("DIST TO TARGET", hudX + 10, hudY + 52);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 13px 'IBM Plex Mono', monospace";
    ctx.fillText(distAU + " AU", hudX + 10, hudY + 67);

    const barX = hudX + 130, barY = hudY + 26, barW = 50, barH = 6;
    const speedFrac = Math.min(speedKms / 80, 1);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    roundRect(ctx, barX, barY, barW, barH, 3); ctx.fill();
    const sr2 = Math.min(255, speedFrac * 400) | 0;
    const sg2 = Math.max(0, 200 - speedFrac * 200) | 0;
    ctx.fillStyle = `rgb(${sr2},${sg2},40)`;
    roundRect(ctx, barX, barY, barW * speedFrac, barH, 3); ctx.fill();

    // Fuel gauge
    if (hasBudget) {
      const fuelY = hudY + 76;
      const fuelW = 170;

      // Sum up executed burns so far
      let burnsDv = 0;
      const firedBurns = [];
      if (result.burns) {
        for (const b of result.burns) {
          if (b.time <= (curPoint ? curPoint.t : 0)) {
            burnsDv += b.dvKms;
            firedBurns.push(b);
          }
        }
      }

      const totalUsed = launchDv + burnsDv;
      const remaining = Math.max(rocket.budget - totalUsed, 0);
      const totalFrac = Math.min(totalUsed / rocket.budget, 1);

      // Count actual measured assist Œîv so far
      let assistDv = 0;
      if (result.assists) {
        for (const a of result.assists) {
          if (a.time <= (curPoint ? curPoint.t : 0)) {
            assistDv += Math.max(0, a.dvKms || 0); // only count speed gains
          }
        }
      }

      ctx.fillStyle = "#888";
      ctx.font = "bold 8px 'IBM Plex Mono', monospace";
      ctx.textAlign = "left";
      ctx.fillText("FUEL", hudX + 10, fuelY);
      ctx.fillStyle = remaining > 0 ? "#aaa" : "#ff5533";
      ctx.font = "8px 'IBM Plex Mono', monospace";
      ctx.fillText(`${remaining.toFixed(1)} / ${rocket.budget.toFixed(1)} km/s left`, hudX + 42, fuelY);

      // Fuel bar background
      const fbX = hudX + 10, fbY = fuelY + 4, fbW = fuelW, fbH = 7;
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      roundRect(ctx, fbX, fbY, fbW, fbH, 3); ctx.fill();

      // Launch portion (orange)
      const launchFrac = Math.min(launchDv / rocket.budget, 1);
      const launchW = fbW * launchFrac;
      ctx.fillStyle = "#ff8844";
      if (launchW > 1) { roundRect(ctx, fbX, fbY, launchW, fbH, 3); ctx.fill(); }

      // Burn portions (purple segments after launch)
      let burnOffset = launchW;
      for (const b of firedBurns) {
        const bFrac = b.dvKms / rocket.budget;
        const bW = Math.max(1, fbW * bFrac);
        ctx.fillStyle = "#bb88ff";
        if (burnOffset + bW <= fbW) {
          ctx.fillRect(fbX + burnOffset, fbY, bW, fbH);
        }
        burnOffset += bW;
      }

      // Remaining portion (green)
      if (totalFrac < 1) {
        ctx.fillStyle = "#00cc66";
        const remStart = Math.min(burnOffset, fbW);
        roundRect(ctx, fbX + remStart, fbY, fbW - remStart, fbH, 3); ctx.fill();
      }

      // Labels on segments
      if (launchW > 30) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.font = "bold 6px 'IBM Plex Mono', monospace";
        ctx.textAlign = "center";
        ctx.fillText("LAUNCH", fbX + launchW / 2, fbY + 5.5);
      }
      if (burnsDv > 0 && (burnOffset - launchW) > 25) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.font = "bold 5px 'IBM Plex Mono', monospace";
        ctx.textAlign = "center";
        ctx.fillText("BURNS", fbX + launchW + (burnOffset - launchW) / 2, fbY + 5.5);
      }

      // If assists gained Œîv, show bonus
      if (assistDv > 0) {
        ctx.textAlign = "left";
        ctx.fillStyle = "#ffdd44";
        ctx.font = "bold 7px 'IBM Plex Mono', monospace";
        ctx.fillText(`+${assistDv.toFixed(1)} km/s gained from assists`, fbX, fbY + fbH + 9);
      }
    }

    // Capture verdict panel (shows after arrival)
    if (result.captureInfo && progress >= 1) {
      const ci = result.captureInfo;
      const cvX = hudX, cvY = hudY + hudH + 10;
      const cvW = 210, cvH = 68;

      // Background
      const borderColor = ci.captured ? "rgba(0,238,119,0.3)" : "rgba(255,170,34,0.3)";
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      roundRect(ctx, cvX, cvY, cvW, cvH, 6); ctx.fill();
      ctx.strokeStyle = borderColor; ctx.lineWidth = 1.5;
      roundRect(ctx, cvX, cvY, cvW, cvH, 6); ctx.stroke();

      ctx.textAlign = "left";

      // Verdict label
      if (ci.captured) {
        ctx.fillStyle = "#00ee77";
        ctx.font = "bold 10px 'IBM Plex Mono', monospace";
        ctx.fillText("üéØ CAPTURED INTO ORBIT", cvX + 10, cvY + 17);
      } else {
        ctx.fillStyle = "#ffaa22";
        ctx.font = "bold 10px 'IBM Plex Mono', monospace";
        ctx.fillText("‚Üó FLYBY ‚Äî NOT CAPTURED", cvX + 10, cvY + 17);
      }

      // Approach speed vs escape velocity bar
      const maxV = Math.max(ci.relVelKms, ci.escVelKms) * 1.3;
      const bX = cvX + 10, bY = cvY + 26, bW = cvW - 20, bH2 = 8;

      // Approach speed bar
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      roundRect(ctx, bX, bY, bW, bH2, 3); ctx.fill();
      const appFrac = Math.min(ci.relVelKms / maxV, 1);
      ctx.fillStyle = ci.captured ? "#00cc66" : "#ff8833";
      roundRect(ctx, bX, bY, bW * appFrac, bH2, 3); ctx.fill();

      // Escape velocity marker line
      const escFrac = Math.min(ci.escVelKms / maxV, 1);
      const escLineX = bX + bW * escFrac;
      ctx.strokeStyle = "rgba(255,255,255,0.8)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(escLineX, bY - 2); ctx.lineTo(escLineX, bY + bH2 + 2); ctx.stroke();

      // Labels
      ctx.font = "8px 'IBM Plex Mono', monospace";
      ctx.fillStyle = ci.captured ? "#88eebb" : "#ffcc88";
      ctx.textAlign = "left";
      ctx.fillText("Approach: " + ci.relVelKms.toFixed(1) + " km/s", bX, bY + bH2 + 12);
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.textAlign = "right";
      ctx.fillText("Escape vel: " + ci.escVelKms.toFixed(1) + " km/s ‚ñº", bX + bW, bY + bH2 + 12);

      // Margin
      ctx.textAlign = "left";
      if (ci.captured) {
        ctx.fillStyle = "#00ee77";
        ctx.fillText("Margin: " + (ci.escVelKms - ci.relVelKms).toFixed(1) + " km/s under", bX, bY + bH2 + 24);
      } else {
        ctx.fillStyle = "#ffaa22";
        ctx.fillText("Excess: " + (ci.relVelKms - ci.escVelKms).toFixed(1) + " km/s over", bX, bY + bH2 + 24);
      }
    }
  }
  drawVelocityChart(prog);
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

const STOP_LABELS = {
  CAPTURED:  { text: "‚úì ORBITAL CAPTURE", cls: "captured" },
  FLYBY:     { text: "‚Üó FLYBY (TOO FAST)", cls: "flyby" },
  ESCAPED:   { text: "‚úó ESCAPED SOLAR SYSTEM", cls: "escaped" },
  SUN_CRASH: { text: "‚òÄ CRASHED INTO SUN", cls: "suncrash" },
  MAX_TIME:  { text: "‚è± MAX SIM TIME REACHED", cls: "missed" },
};

function drawVelocityChart(prog) {
  if (!result || velWrap.classList.contains("collapsed")) return;

  const r = velCanvas.getBoundingClientRect();
  const W = r.width, H = r.height;
  if (W < 10 || H < 10) return;

  // Ensure canvas is sized
  if (velCanvas.width !== W * devicePixelRatio) resizeVelChart();

  const vc = velCtx;
  vc.save();
  // Reset transform and clear
  vc.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

  // Chart margins
  const ml = 52, mr = 14, mt = 20, mb = 22;
  const cw = W - ml - mr, ch = H - mt - mb;

  // Background
  vc.fillStyle = "#08080f";
  vc.fillRect(0, 0, W, H);

  const trail = result.trail;
  if (trail.length < 2) { vc.restore(); return; }

  const visCount = Math.floor(prog * trail.length);
  if (visCount < 2) { vc.restore(); return; }

  // Convert speeds to km/s and get time range
  const totalDays = trail[trail.length - 1].t * 365.25;
  const visDays = trail[visCount - 1].t * 365.25;

  // Compute max speed across ALL trail points for stable Y axis
  let maxSpd = 0;
  for (let i = 0; i < trail.length; i++) {
    const spd = (trail[i].speed / EARTH_V) * REAL_EARTH_V_KMS;
    if (spd > maxSpd) maxSpd = spd;
  }
  maxSpd = Math.ceil(maxSpd / 5) * 5 + 5; // Round up nicely with padding

  // Y axis gridlines and labels
  vc.textAlign = "right";
  vc.textBaseline = "middle";
  vc.font = "8px 'IBM Plex Mono', monospace";
  const ySteps = Math.min(5, Math.ceil(maxSpd / 10));
  const yStep = maxSpd / ySteps;

  for (let i = 0; i <= ySteps; i++) {
    const v = yStep * i;
    const y = mt + ch - (v / maxSpd) * ch;
    vc.strokeStyle = "rgba(255,255,255,0.04)";
    vc.lineWidth = 1;
    vc.beginPath(); vc.moveTo(ml, y); vc.lineTo(ml + cw, y); vc.stroke();
    vc.fillStyle = "rgba(255,255,255,0.3)";
    vc.fillText(v.toFixed(0), ml - 6, y);
  }

  // Y axis label
  vc.save();
  vc.translate(10, mt + ch / 2);
  vc.rotate(-Math.PI / 2);
  vc.textAlign = "center";
  vc.fillStyle = "rgba(255,255,255,0.2)";
  vc.font = "bold 7px 'IBM Plex Mono', monospace";
  vc.fillText("km/s", 0, 0);
  vc.restore();

  // X axis labels
  vc.textAlign = "center";
  vc.textBaseline = "top";
  vc.font = "8px 'IBM Plex Mono', monospace";
  vc.fillStyle = "rgba(255,255,255,0.25)";
  const xLabelCount = Math.min(6, Math.floor(cw / 70));
  for (let i = 0; i <= xLabelCount; i++) {
    const d = (totalDays / xLabelCount) * i;
    const x = ml + (d / totalDays) * cw;
    vc.fillText("D" + Math.round(d), x, mt + ch + 6);
  }

  // Gravity assist vertical markers (behind the line)
  if (result.assists) {
    for (const a of result.assists) {
      const ad = a.time * 365.25;
      if (ad > visDays) continue;
      const x = ml + (ad / totalDays) * cw;
      vc.strokeStyle = "rgba(255,220,40,0.25)";
      vc.lineWidth = 1;
      vc.setLineDash([3, 3]);
      vc.beginPath(); vc.moveTo(x, mt); vc.lineTo(x, mt + ch); vc.stroke();
      vc.setLineDash([]);
      // Label at top
      vc.fillStyle = "rgba(255,220,40,0.7)";
      vc.font = "bold 7px 'IBM Plex Mono', monospace";
      vc.textAlign = "center"; vc.textBaseline = "bottom";
      const dvSign = a.dvKms >= 0 ? "+" : "";
      const dvColor = a.dvKms >= 0 ? "rgba(0,238,119,0.8)" : "rgba(255,100,50,0.8)";
      vc.fillText("‚ö°" + a.planet, x, mt - 8);
      vc.fillStyle = dvColor;
      vc.fillText(dvSign + a.dvKms.toFixed(1) + " km/s", x, mt - 1);
    }
  }

  // Maneuver burn vertical markers
  if (result.burns) {
    for (const b of result.burns) {
      const bd = b.time * 365.25;
      if (bd > visDays) continue;
      const x = ml + (bd / totalDays) * cw;
      vc.strokeStyle = "rgba(187,136,255,0.3)";
      vc.lineWidth = 1;
      vc.setLineDash([3, 3]);
      vc.beginPath(); vc.moveTo(x, mt); vc.lineTo(x, mt + ch); vc.stroke();
      vc.setLineDash([]);
      vc.fillStyle = "rgba(187,136,255,0.7)";
      vc.font = "bold 7px 'IBM Plex Mono', monospace";
      vc.textAlign = "center"; vc.textBaseline = "bottom";
      vc.fillText("‚óÜBURN", x, mt - 1);
    }
  }

  // Velocity line ‚Äî gradient from blue to orange
  vc.lineWidth = 1.5;
  vc.beginPath();
  for (let i = 0; i < visCount; i++) {
    const d = trail[i].t * 365.25;
    const spd = (trail[i].speed / EARTH_V) * REAL_EARTH_V_KMS;
    const x = ml + (d / totalDays) * cw;
    const y = mt + ch - (spd / maxSpd) * ch;
    if (i === 0) vc.moveTo(x, y); else vc.lineTo(x, y);
  }
  // Create gradient along x
  const grad = vc.createLinearGradient(ml, 0, ml + cw * prog, 0);
  grad.addColorStop(0, "rgba(90,170,255,0.85)");
  grad.addColorStop(0.5, "rgba(255,170,70,0.85)");
  grad.addColorStop(1, "rgba(255,100,50,0.9)");
  vc.strokeStyle = grad;
  vc.stroke();

  // Fill under the curve (subtle)
  vc.lineTo(ml + (trail[visCount - 1].t * 365.25 / totalDays) * cw, mt + ch);
  vc.lineTo(ml, mt + ch);
  vc.closePath();
  const fillGrad = vc.createLinearGradient(0, mt, 0, mt + ch);
  fillGrad.addColorStop(0, "rgba(255,140,60,0.08)");
  fillGrad.addColorStop(1, "rgba(255,140,60,0)");
  vc.fillStyle = fillGrad;
  vc.fill();

  // Playhead (vertical line at current position)
  if (visCount > 0) {
    const curD = trail[visCount - 1].t * 365.25;
    const curSpd = (trail[visCount - 1].speed / EARTH_V) * REAL_EARTH_V_KMS;
    const px = ml + (curD / totalDays) * cw;
    const py = mt + ch - (curSpd / maxSpd) * ch;

    vc.strokeStyle = "rgba(255,255,255,0.2)";
    vc.lineWidth = 1;
    vc.beginPath(); vc.moveTo(px, mt); vc.lineTo(px, mt + ch); vc.stroke();

    // Dot on the line
    vc.fillStyle = "#fff";
    vc.beginPath(); vc.arc(px, py, 3, 0, PI2); vc.fill();
    vc.fillStyle = "rgba(255,255,255,0.7)";
    vc.font = "bold 8px 'IBM Plex Mono', monospace";
    vc.textBaseline = "bottom";
    // Flip label to left side if near right edge
    if (px > ml + cw - 60) {
      vc.textAlign = "right";
      vc.fillText(curSpd.toFixed(1) + " km/s", px - 6, py - 4);
    } else {
      vc.textAlign = "left";
      vc.fillText(curSpd.toFixed(1) + " km/s", px + 6, py - 4);
    }
  }

  // Update info text
  if (visCount > 0) {
    const curSpd = (trail[visCount - 1].speed / EARTH_V) * REAL_EARTH_V_KMS;
    const minSpd = Math.min(...trail.slice(0, visCount).map(t => (t.speed / EARTH_V) * REAL_EARTH_V_KMS));
    const maxSpdVis = Math.max(...trail.slice(0, visCount).map(t => (t.speed / EARTH_V) * REAL_EARTH_V_KMS));
    velInfo.textContent = `now: ${curSpd.toFixed(1)} ¬∑ min: ${minSpd.toFixed(1)} ¬∑ max: ${maxSpdVis.toFixed(1)} km/s`;
  }

  vc.restore();
}

function launch() {
  if (animId) cancelAnimationFrame(animId);
  const boost = +boostSlider.value;
  const angle = +angleSlider.value;
  const dest  = destSel.value;
  const launchDay = +dateSlider.value;
  const launchTimeYears = launchDay / 365.25;

  result = simulate(boost, angle, dest, launchTimeYears, maneuverNodes);
  progress = 0; running = true; paused = false;
  collapseControls();
  velWrap.classList.add("visible");
  resizeVelChart();
  launchBtn.disabled = true;
  launchBtn.textContent = "‚ü≥ RUNNING...";
  pauseBtn.textContent = "‚è∏ STOP";
  pauseBtn.classList.remove("paused");
  statusEl.textContent = ""; statusEl.className = "";
  tipEl.style.display = "none";

  storedBaseFrames = Math.max(300, Math.min(result.trail.length * 0.8, 800));
  let lastTime = performance.now();

  function tick(now) {
    if (paused) return;
    const animSpeed = +speedSlider.value;
    const elapsed = (now - lastTime) / 1000;
    lastTime = now;
    const increment = (animSpeed * elapsed * 60) / storedBaseFrames;
    progress = Math.min(progress + increment, 1);
    draw(progress);
    if (progress < 1) {
      animId = requestAnimationFrame(tick);
    } else {
      running = false; paused = false;
      launchBtn.disabled = false;
      launchBtn.textContent = "‚ñ∂ LAUNCH";
      pauseBtn.textContent = "‚è∏ STOP";
      pauseBtn.classList.remove("paused");
      showStatus();
    }
  }
  animId = requestAnimationFrame(tick);
}

function showStatus() {
  if (!result) return;
  const days = (result.time * 365.25).toFixed(0);
  const a = result.assists;
  const aStr = a.length > 0
    ? ` ¬∑ ${a.length} assist${a.length !== 1 ? "s" : ""}: ${a.map(x => {
        const sign = x.dvKms >= 0 ? "+" : "";
        return x.planet + " (" + sign + x.dvKms.toFixed(1) + ")";
      }).join(", ")}` : "";
  const bStr = result.burns && result.burns.length > 0
    ? ` ¬∑ ${result.burns.length} burn${result.burns.length !== 1 ? "s" : ""} (${result.burns.reduce((s, b) => s + b.dvKms, 0).toFixed(1)} km/s)` : "";

  // Determine the effective stop reason (split ARRIVED into CAPTURED vs FLYBY)
  let effectiveReason = result.stopReason;
  if (result.stopReason === "ARRIVED" && result.captureInfo) {
    effectiveReason = result.captureInfo.captured ? "CAPTURED" : "FLYBY";
  }

  const label = STOP_LABELS[effectiveReason] || STOP_LABELS.MAX_TIME;
  statusEl.className = label.cls;

  let captureDetail = "";
  if (result.captureInfo) {
    const ci = result.captureInfo;
    captureDetail = ` ¬∑ approach: ${ci.relVelKms.toFixed(1)} km/s vs escape: ${ci.escVelKms.toFixed(1)} km/s`;
  }

  statusEl.innerHTML = `${label.text} <span class="detail">${days} days${aStr}${bStr}${captureDetail}</span>`;

  if (effectiveReason === "FLYBY") {
    const ci = result.captureInfo;
    const excess = (ci.relVelKms - ci.escVelKms).toFixed(1);
    const burnHint = result.burns.length === 0
      ? ` Or add a maneuver burn near ${destSel.value} to brake ‚Äî like pressing the brakes before a turn.`
      : ` Your maneuver burns fired but you're still ${excess} km/s too fast. Try adding a retrograde burn (angle 180¬∞) closer to arrival.`;
    tipEl.innerHTML = `‚Üó You reached ${destSel.value} but were going ${excess} km/s too fast to be captured. ` +
      `Try reducing your boost ‚Äî you need your approach speed under ${ci.escVelKms} km/s. ` +
      `Think of it like rolling a marble into a bowl: too fast and it rolls right over.${burnHint}`;
    tipEl.style.display = "block";
  } else if (effectiveReason === "CAPTURED") {
    const ci = result.captureInfo;
    const margin = (ci.escVelKms - ci.relVelKms).toFixed(1);
    tipEl.innerHTML = `üéØ The planet's gravity captured the spacecraft with ${margin} km/s to spare. ` +
      `In reality, a small braking burn would circularize the orbit from here.`;
    tipEl.style.display = "block";
  } else if (result.stopReason === "ESCAPED") {
    tipEl.innerHTML = "üöÄ Escaped the solar system! Reduce boost or change angle.";
    tipEl.style.display = "block";
  } else if (result.stopReason === "SUN_CRASH") {
    tipEl.innerHTML = "‚òÄÔ∏è Crashed into the Sun! Try a different angle for more sideways speed.";
    tipEl.style.display = "block";
  } else if (result.stopReason === "MAX_TIME") {
    tipEl.innerHTML = "‚è± Ran out of sim time. Try launching during a green window with the ideal boost/angle.";
    tipEl.style.display = "block";
  } else {
    tipEl.style.display = "none";
  }
}

launchBtn.addEventListener("click", launch);
resize();
updateWindowInfo();
updateRocketInfo();
</script>
</body>
</html>
